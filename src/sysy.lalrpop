use crate::ast::*;
use crate::utils::RcRef;

grammar;

match {
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/" => {},
  _
}

//! We fold all const expressions when parsing. See ExpEval and Exp.
//! The EBNF we followed:
//! 
//! CompUnit      ::= [CompUnit] (Decl | FuncDef);
//! Decl          ::= ConstDecl | VarDecl;
//! ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
//! BType         ::= "int";
//! ConstIdxList  ::= {"[" ConstExp "]"};
//! ConstDef      ::= IDENT ConstIdxList "=" ConstInitVal;
//! ConstInitVal  ::= ConstExp | "{" [ConstInitVal {"," ConstInitVal}] "}";
//! VarDecl       ::= BType VarDef {"," VarDef} ";";
//! VarDef        ::= IDENT ConstIdxList
//!         | IDENT ConstIdxList "=" InitVal;
//! InitVal       ::= Exp | "{" [InitVal {"," InitVal}] "}";
//!
//! FuncDef       ::= FuncType IDENT "(" [FuncFParams] ")" Block;
//! FuncType      ::= "void" | "int";
//! FuncFParams   ::= FuncFParam {"," FuncFParam};
//! FuncFParam    ::= BType IDENT ["[" "]" ConstIdxList];
//!
//! Block         ::= "{" {BlockItem} "}";
//! BlockItem     ::= Decl | Stmt;
//!
//! We have to pay some effort to solve dangling-else conflict:
//! see https://en.wikipedia.org/wiki/Dangling_else#Avoiding_the_conflict_in_LR_parsers
//! 
//! Stmt          ::= StmtIfClose | StmtIfOpen;
//! StmtIfClose   ::= StmtNotEndInStmt 
//!         | "if" "(" Exp ")" StmtIfClose "else" StmtIfClose
//!         | "while" "(" Exp ")" StmtIfClose;
//! StmtIfOpen    ::= "if" "(" Exp ")" Stmt 
//!         | "if" "(" Exp ")" StmtIfClose "else" StmtIfOpen
//!         | "while" "(" Exp ")" StmtIfOpen;
//! StmtNotEndInStmt  ::= LVal "=" Exp ";"
//!         | [Exp] ";"
//!         | Block
//!         | "break" ";"
//!         | "continue" ";"
//!         | "return" [Exp] ";";
//!
//! Exp           ::= LOrExp;
//! LVal          ::= IDENT {"[" Exp "]"};
//! PrimaryExp    ::= "(" Exp ")" | LVal | Number;
//! Number        ::= INT_CONST;
//! UnaryExp      ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
//! UnaryOp       ::= "+" | "-" | "!";
//! FuncRParams   ::= Exp {"," Exp};
//! MulExp        ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
//! AddExp        ::= MulExp | AddExp ("+" | "-") MulExp;
//! RelExp        ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
//! EqExp         ::= RelExp | EqExp ("==" | "!=") RelExp;
//! LAndExp       ::= EqExp | LAndExp "&&" EqExp;
//! LOrExp        ::= LAndExp | LOrExp "||" LAndExp;
//! ConstExp      ::= Exp;

Comma<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

CommaNotEmpty<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T> => {
      v.push(e);
      v
    }
};

pub _CompUnit: RcRef<CompUnit> = {
  <_CompUnitItem+> => RcRef::new(<>)
};

_CompUnitItem: RcRef<CompUnitItem> = {
  <_FuncDef>  => RcRef::new(CompUnitItem::FuncDef(<>)),
  <_Decl>     => RcRef::new(CompUnitItem::Decl(<>))
};

_Decl: RcRef<Decl> = {
  <_ConstDecl>  => RcRef::new(Decl::Const(<>)),
  <_VarDecl>    => RcRef::new(Decl::Var(<>))
};

_ConstDecl: RcRef<ConstDecl> = {
  "const" <btype: _BType> <const_defs: CommaNotEmpty<_ConstDef>> ";" 
    => RcRef::new(ConstDecl { const_defs })
};

_ConstIdxList: Vec<RcRef<ExpEval>> = {
  <("[" <_ConstExp> "]")*> 
    => <>
};

_BType: i32 = {
  "int" => 0
};

_ConstDef: RcRef<ConstDef> = {
  <ident: _Ident> <idx: _ConstIdxList> "=" <const_init_val: _ConstInitVal> => {
    RcRef::new(ConstDef { <> })
  }
};

_ConstInitVal: RcRef<InitVal> = {
  <_ConstExp>                     => RcRef::new(InitVal::Single(<>)),
  "{" <Comma<_ConstInitVal>> "}"  => RcRef::new(InitVal::Sequence(<>))
};

_VarDecl: RcRef<VarDecl> = {
  <x: _BType> <var_defs: CommaNotEmpty<_VarDef>> ";" 
    => RcRef::new(VarDecl { var_defs })
};

_VarDef: RcRef<VarDef> = {
  <ident: _Ident> <idx: _ConstIdxList> <init_val: ("=" <_InitVal>)?> 
    => RcRef::new(VarDef { <> })
};

_InitVal: RcRef<InitVal> = {
  <_Exp>                    => RcRef::new(InitVal::Single(<>)),
  "{" <Comma<_InitVal>> "}" => RcRef::new(InitVal::Sequence(<>))
};


_FuncDef: RcRef<FuncDef> = {
  "void" <ident: _Ident> "(" <func_f_params: _FuncFParams> ")" <block: _Block> 
    => RcRef::new(FuncDef { has_retval: false, ident, func_f_params, block }),
  <t: _BType> <ident: _Ident> "(" <func_f_params: _FuncFParams> ")" <block: _Block>
    => RcRef::new(FuncDef { has_retval: true, ident, func_f_params, block })
};

_FuncFParams: Vec<RcRef<FuncFParam>> = {
  <Comma<_FuncFParam>> => <>
};

_FuncFParam: RcRef<FuncFParam> = {
  <btype: _BType> <ident: _Ident> <shape_except_first_dimension: ("[" "]" <_ConstIdxList>)?> 
    => RcRef::new(FuncFParam { ident, shape_except_first_dimension })
};

_Block: RcRef<Block> = {
  "{" <_BlockItem*> "}" => RcRef::new(Block::new(<>))
};

_BlockItem: RcRef<BlockItem> = {
  <_Decl> => RcRef::new(BlockItem::Decl(<>)),
  <_Stmt> => RcRef::new(BlockItem::Stmt(<>))
};

_Stmt: RcRef<Stmt> = {
  <_StmtIfClose>      => <>,
  <_StmtIfOpen>       => <>
};

_StmtIfOpen: RcRef<Stmt> = {
  "if" "(" <exp: _Exp> ")" <stmt: _Stmt> 
                    => RcRef::new(Stmt::IfElse(exp, stmt, None)),
  "if" "(" <exp: _Exp> ")" <stmt1: _StmtIfClose> "else" <stmt2: _StmtIfOpen> 
      => RcRef::new(Stmt::IfElse(exp, stmt1, Some(stmt2))),
  "while" "(" <exp: _Exp> ")" <stmt: _StmtIfOpen> 
                              => RcRef::new(Stmt::While(exp, stmt))
};

_StmtIfClose: RcRef<Stmt> = {
  <_StmtNotEndInStmt>   => <>, 
  "if" "(" <exp: _Exp> ")" <stmt1: _StmtIfClose> "else" <stmt2: _StmtIfClose> 
      => RcRef::new(Stmt::IfElse(exp, stmt1, Some(stmt2))),
  "while" "(" <exp: _Exp> ")" <stmt: _StmtIfClose>
                              => RcRef::new(Stmt::While(exp, stmt))
};

_StmtNotEndInStmt: RcRef<Stmt> = {
  <_LVal> "=" <_Exp> ";"      => RcRef::new(Stmt::Assign(<>)),
  <_Exp?> ";"                 => RcRef::new(Stmt::Exp(<>)),
  <_Block>                    => RcRef::new(Stmt::Block(<>)),
  "break" ";"                 => RcRef::new(Stmt::Break),
  "continue" ";"              => RcRef::new(Stmt::Continue),
  "return" <_Exp?> ";"        => RcRef::new(Stmt::Return(<>))
};

_Exp: RcRef<ExpEval> = 
  <_LOrExp> => <>;

_LVal: RcRef<LVal> = {
  <name: _Ident> <idx: ("[" <_Exp> "]")*> => RcRef::new(LVal { <> })
};

_PrimaryExp: RcRef<ExpEval> = {
  "(" <_Exp> ")"  => <>,
  <_LVal>         => RcRef::new(ExpEval::new_lval(<>)),
  <_Number>       => RcRef::new(ExpEval::new_number(<>))
};

_Number: Number = {
  <_IntConst> => <>
};

_UnaryExp: RcRef<ExpEval> = {
  <_PrimaryExp>                   => <>,
  <_Ident> "(" <_FuncRParams> ")" => RcRef::new(ExpEval::new_call(<>)),
  <unary_op: _UnaryOp> <unary_exp: _UnaryExp> 
                                  => RcRef::new(ExpEval::new_unary(unary_op, unary_exp))
};

_UnaryOp: UnaryOp = {
  "+" => UnaryOp::Pos,
  "-" => UnaryOp::Neg,
  "!" => UnaryOp::Not
};

_FuncRParams: Vec<RcRef<ExpEval>> = {
  CommaNotEmpty<_Exp> => <>
};

_MulOp: BinaryOp = {
  "*" => BinaryOp::Mul,
  "/" => BinaryOp::Div,
  "%" => BinaryOp::Mod
};

_AddOp: BinaryOp = {
  "+" => BinaryOp::Add,
  "-" => BinaryOp::Sub
};

_RelOp: BinaryOp = {
  "<"  => BinaryOp::Lt,
  ">"  => BinaryOp::Gt,
  "<=" => BinaryOp::Le,
  ">=" => BinaryOp::Ge
};

_EqOp: BinaryOp = {
  "==" => BinaryOp::Eq,
  "!=" => BinaryOp::Ne
};

_MulExp: RcRef<ExpEval> = {
  <mul_exp: _MulExp> <op: _MulOp> <unary_exp: _UnaryExp> 
                => RcRef::new(ExpEval::new_binary(mul_exp, op, unary_exp)),
  <_UnaryExp>   => <>
};

_AddExp: RcRef<ExpEval> = {
  <add_exp: _AddExp> <op: _AddOp> <mul_exp: _MulExp> 
                => RcRef::new(ExpEval::new_binary(add_exp, op, mul_exp)),
  <_MulExp>     => <>
};

_RelExp: RcRef<ExpEval> = {
  <rel_exp: _RelExp> <op: _RelOp> <add_exp: _AddExp> 
                => RcRef::new(ExpEval::new_binary(rel_exp, op, add_exp)),
  <_AddExp>     => <>
};

_EqExp: RcRef<ExpEval> = {
  <eq_exp: _EqExp> <op: _EqOp> <rel_exp: _RelExp> 
                => RcRef::new(ExpEval::new_binary(eq_exp, op, rel_exp)),
  <_RelExp>     => <>
};

_LAndExp: RcRef<ExpEval> = {
  <land_exp: _LAndExp> "&&" <eq_exp: _EqExp> 
                => RcRef::new(ExpEval::new_binary(land_exp, BinaryOp::And, eq_exp)),
  <_EqExp>      => <>
};

_LOrExp: RcRef<ExpEval> = {
  <lor_exp: _LOrExp> "||" <land_exp: _LAndExp> 
                => RcRef::new(ExpEval::new_binary(lor_exp, BinaryOp::Or, land_exp)),
  <_LAndExp>    => <>
};

_Ident: String = 
  r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

_IntConst: i32 = {
  r"[1-9][0-9]*"        => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*"            => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+"  => i32::from_str_radix(&<>[2..], 16).unwrap()
};

_ConstExp: RcRef<ExpEval> = 
  <_Exp> => <>;
