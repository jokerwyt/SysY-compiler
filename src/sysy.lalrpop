use crate::ast::*;
use crate::utils::RcRef;

grammar;

match {
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/" => {},
  _
}

//! We fold all const expressions when parsing. See ExpEval and Exp.
//! The EBNF we followed:
//! 
//! CompUnit      ::= [CompUnit] (Decl | FuncDef);
//! Decl          ::= ConstDecl | VarDecl;
//! ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
//! BType         ::= "int";
//! ConstIdxList  ::= {"[" ConstExp "]"};
//! ConstDef      ::= IDENT ConstIdxList "=" ConstInitVal;
//! ConstInitVal  ::= ConstExp | "{" [ConstInitVal {"," ConstInitVal}] "}";
//! VarDecl       ::= BType VarDef {"," VarDef} ";";
//! VarDef        ::= IDENT ConstIdxList
//!         | IDENT ConstIdxList "=" InitVal;
//! InitVal       ::= Exp | "{" [InitVal {"," InitVal}] "}";
//!
//! FuncDef       ::= FuncType IDENT "(" [FuncFParams] ")" Block;
//! FuncType      ::= "void" | "int";
//! FuncFParams   ::= FuncFParam {"," FuncFParam};
//! FuncFParam    ::= BType IDENT ["[" "]" ConstIdxList];
//!
//! Block         ::= "{" {BlockItem} "}";
//! BlockItem     ::= Decl | Stmt;
//!
//! We have to pay some effort to solve dangling-else conflict:
//! see https://en.wikipedia.org/wiki/Dangling_else#Avoiding_the_conflict_in_LR_parsers
//! 
//! Stmt          ::= StmtIfClose | StmtIfOpen;
//! StmtIfClose   ::= StmtNotEndInStmt 
//!         | "if" "(" Exp ")" StmtIfClose "else" StmtIfClose
//!         | "while" "(" Exp ")" StmtIfClose;
//! StmtIfOpen    ::= "if" "(" Exp ")" Stmt 
//!         | "if" "(" Exp ")" StmtIfClose "else" StmtIfOpen
//!         | "while" "(" Exp ")" StmtIfOpen;
//! StmtNotEndInStmt  ::= LVal "=" Exp ";"
//!         | [Exp] ";"
//!         | Block
//!         | "break" ";"
//!         | "continue" ";"
//!         | "return" [Exp] ";";
//!
//! Exp           ::= LOrExp;
//! LVal          ::= IDENT {"[" Exp "]"};
//! PrimaryExp    ::= "(" Exp ")" | LVal | Number;
//! Number        ::= INT_CONST;
//! UnaryExp      ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
//! UnaryOp       ::= "+" | "-" | "!";
//! FuncRParams   ::= Exp {"," Exp};
//! MulExp        ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
//! AddExp        ::= MulExp | AddExp ("+" | "-") MulExp;
//! RelExp        ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
//! EqExp         ::= RelExp | EqExp ("==" | "!=") RelExp;
//! LAndExp       ::= EqExp | LAndExp "&&" EqExp;
//! LOrExp        ::= LAndExp | LOrExp "||" LAndExp;
//! ConstExp      ::= Exp;

Comma<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

CommaNotEmpty<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T> => {
      v.push(e);
      v
    }
};

pub _CompUnit: CompUnit = {
  <_CompUnitItem+> => <>
};

_CompUnitItem: CompUnitItem = {
  <_FuncDef>  => CompUnitItem::FuncDef(<>),
  <_Decl>     => CompUnitItem::Decl(<>)
};

_Decl: Decl = {
  <_ConstDecl>  => Decl::Const(<>),
  <_VarDecl>    => Decl::Var(<>)
};

_ConstDecl: ConstDecl = {
  "const" <btype: _BType> <const_defs: CommaNotEmpty<_ConstDef>> ";" 
    => ConstDecl { const_defs }
};

_ConstIdxList: Vec<ExpEval> = {
  <("[" <_ConstExp> "]")*> 
    => <>
};

_BType: i32 = {
  "int" => 0
};

_ConstDef: ConstDef = {
  <ident: _Ident> <idx: _ConstIdxList> "=" <const_init_val: _ConstInitVal> => {
    ConstDef { <> }
  }
};

_ConstInitVal: InitVal = {
  <_ConstExp>                     => InitVal::Single(<>),
  "{" <Comma<_ConstInitVal>> "}"  => InitVal::Sequence(<>)
};

_VarDecl: VarDecl = {
  <x: _BType> <var_defs: CommaNotEmpty<_VarDef>> ";" 
    => VarDecl { var_defs }
};

_VarDef: VarDef = {
  <ident: _Ident> <idx: _ConstIdxList> <init_val: ("=" <_InitVal>)?> 
    => VarDef { <> }
};

_InitVal: InitVal = {
  <_Exp>                    => InitVal::Single(<>),
  "{" <Comma<_InitVal>> "}" => InitVal::Sequence(<>)
};


_FuncDef: FuncDef = {
  "void" <ident: _Ident> "(" <func_f_params: _FuncFParams> ")" <block: _Block> 
    => FuncDef { has_retval: false, ident, func_f_params, block },
  <t: _BType> <ident: _Ident> "(" <func_f_params: _FuncFParams> ")" <block: _Block>
    => FuncDef { has_retval: true, ident, func_f_params, block }
};

_FuncFParams: Vec<FuncFParam> = {
  <Comma<_FuncFParam>> => <>
};

_FuncFParam: FuncFParam = {
  <btype: _BType> <ident: _Ident> <shape_exclude_first_dimension: ("[" "]" <_ConstIdxList>)?> 
    => FuncFParam { ident, shape_exclude_first_dimension }
};

_Block: Block = {
  "{" <_BlockItem*> "}" => Block::new(<>)
};

_BlockItem: BlockItem = {
  <_Decl> => BlockItem::Decl(<>),
  <_Stmt> => BlockItem::Stmt(<>)
};

_Stmt: Stmt = {
  <_StmtIfClose>      => <>,
  <_StmtIfOpen>       => <>
};

_StmtIfOpen: Stmt = {
  "if" "(" <exp: _Exp> ")" <stmt: _Stmt> 
            => Stmt::IfElse(exp, Box::new(stmt), None),
  "if" "(" <exp: _Exp> ")" <stmt1: _StmtIfClose> "else" <stmt2: _StmtIfOpen> 
            => Stmt::IfElse(exp, Box::new(stmt1), Some(Box::new(stmt2))),
  "while" "(" <exp: _Exp> ")" <stmt: _StmtIfOpen> 
            => Stmt::While(exp, Box::new(stmt))
};

_StmtIfClose: Stmt = {
  <_StmtNotEndInStmt>   => <>, 
  "if" "(" <exp: _Exp> ")" <stmt1: _StmtIfClose> "else" <stmt2: _StmtIfClose> 
          => Stmt::IfElse(exp, Box::new(stmt1), Some(Box::new(stmt2))),
  "while" "(" <exp: _Exp> ")" <stmt: _StmtIfClose>
          => Stmt::While(exp, Box::new(stmt))
};

_StmtNotEndInStmt: Stmt = {
  <_LVal> "=" <_Exp> ";"      => Stmt::Assign(<>),
  <_Exp?> ";"                 => Stmt::Exp(<>),
  <_Block>                    => Stmt::Block(<>),
  "break" ";"                 => Stmt::Break,
  "continue" ";"              => Stmt::Continue,
  "return" <_Exp?> ";"        => Stmt::Return(<>)
};

_Exp: ExpEval = 
  <_LOrExp> => <>;

_LVal: LVal = {
  <name: _Ident> <idx: ("[" <_Exp> "]")*> => LVal { <> }
};

_PrimaryExp: ExpEval = {
  "(" <_Exp> ")"  => <>,
  <_LVal>         => ExpEval::new_lval(<>),
  <_Number>       => ExpEval::new_number(<>)
};

_Number: Number = {
  <_IntConst> => <>
};

_UnaryExp: ExpEval = {
  <_PrimaryExp>                   => <>,
  <_Ident> "(" <_FuncRParams> ")" => ExpEval::new_call(<>),
  <unary_op: _UnaryOp> <unary_exp: _UnaryExp> 
                                  => ExpEval::new_unary(unary_op, unary_exp)
};

_UnaryOp: UnaryOp = {
  "+" => UnaryOp::Pos,
  "-" => UnaryOp::Neg,
  "!" => UnaryOp::Not
};

_FuncRParams: Vec<ExpEval> = {
  CommaNotEmpty<_Exp> => <>
};

_MulOp: BinaryOp = {
  "*" => BinaryOp::Mul,
  "/" => BinaryOp::Div,
  "%" => BinaryOp::Mod
};

_AddOp: BinaryOp = {
  "+" => BinaryOp::Add,
  "-" => BinaryOp::Sub
};

_RelOp: BinaryOp = {
  "<"  => BinaryOp::Lt,
  ">"  => BinaryOp::Gt,
  "<=" => BinaryOp::Le,
  ">=" => BinaryOp::Ge
};

_EqOp: BinaryOp = {
  "==" => BinaryOp::Eq,
  "!=" => BinaryOp::Ne
};

_MulExp: ExpEval = {
  <mul_exp: _MulExp> <op: _MulOp> <unary_exp: _UnaryExp> 
                => ExpEval::new_binary(mul_exp, op, unary_exp),
  <_UnaryExp>   => <>
};

_AddExp: ExpEval = {
  <add_exp: _AddExp> <op: _AddOp> <mul_exp: _MulExp> 
                => ExpEval::new_binary(add_exp, op, mul_exp),
  <_MulExp>     => <>
};

_RelExp: ExpEval = {
  <rel_exp: _RelExp> <op: _RelOp> <add_exp: _AddExp> 
                => ExpEval::new_binary(rel_exp, op, add_exp),
  <_AddExp>     => <>
};

_EqExp: ExpEval = {
  <eq_exp: _EqExp> <op: _EqOp> <rel_exp: _RelExp> 
                => ExpEval::new_binary(eq_exp, op, rel_exp),
  <_RelExp>     => <>
};

_LAndExp: ExpEval = {
  <land_exp: _LAndExp> "&&" <eq_exp: _EqExp> 
                => ExpEval::new_binary(land_exp, BinaryOp::And, eq_exp),
  <_EqExp>      => <>
};

_LOrExp: ExpEval = {
  <lor_exp: _LOrExp> "||" <land_exp: _LAndExp> 
                => ExpEval::new_binary(lor_exp, BinaryOp::Or, land_exp),
  <_LAndExp>    => <>
};

_Ident: String = 
  r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

_IntConst: i32 = {
  r"[1-9][0-9]*"        => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*"            => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+"  => i32::from_str_radix(&<>[2..], 16).unwrap()
};

_ConstExp: ExpEval = 
  <_Exp> => <>;
