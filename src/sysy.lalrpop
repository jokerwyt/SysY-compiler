use crate::ast::*;
use crate::utils::RcRef;

grammar;

match {
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/" => {},
  _
}

//! We fold all const expressions when parsing. See ExpEval and Exp.
//! The EBNF we followed:
//! 
//! CompUnit      ::= [CompUnit] (Decl | FuncDef);
//! Decl          ::= ConstDecl | VarDecl;
//! ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
//! BType         ::= "int";
//! ConstIdxList  ::= {"[" ConstExp "]"};
//! ConstDef      ::= IDENT ConstIdxList "=" ConstInitVal;
//! ConstInitVal  ::= ConstExp | "{" [ConstInitVal {"," ConstInitVal}] "}";
//! VarDecl       ::= BType VarDef {"," VarDef} ";";
//! VarDef        ::= IDENT ConstIdxList
//!         | IDENT ConstIdxList "=" InitVal;
//! InitVal       ::= Exp | "{" [InitVal {"," InitVal}] "}";
//!
//! FuncDef       ::= FuncType IDENT "(" [FuncFParams] ")" Block;
//! FuncType      ::= "void" | "int";
//! FuncFParams   ::= FuncFParam {"," FuncFParam};
//! FuncFParam    ::= BType IDENT ["[" "]" ConstIdxList];
//!
//! Block         ::= "{" {BlockItem} "}";
//! BlockItem     ::= Decl | Stmt;
//!
//! We have to pay some effort to solve dangling-else conflict:
//! see https://en.wikipedia.org/wiki/Dangling_else#Avoiding_the_conflict_in_LR_parsers
//! 
//! Stmt          ::= StmtIfClose | StmtIfOpen;
//! StmtIfClose   ::= StmtNotEndInStmt 
//!         | "if" "(" Exp ")" StmtIfClose "else" StmtIfClose
//!         | "while" "(" Exp ")" StmtIfClose;
//! StmtIfOpen    ::= "if" "(" Exp ")" Stmt 
//!         | "if" "(" Exp ")" StmtIfClose "else" StmtIfOpen
//!         | "while" "(" Exp ")" StmtIfOpen;
//! StmtNotEndInStmt  ::= LVal "=" Exp ";"
//!         | [Exp] ";"
//!         | Block
//!         | "break" ";"
//!         | "continue" ";"
//!         | "return" [Exp] ";";
//!
//! Exp           ::= LOrExp;
//! LVal          ::= IDENT {"[" Exp "]"};
//! PrimaryExp    ::= "(" Exp ")" | LVal | Number;
//! Number        ::= INT_CONST;
//! UnaryExp      ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
//! UnaryOp       ::= "+" | "-" | "!";
//! FuncRParams   ::= Exp {"," Exp};
//! MulExp        ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
//! AddExp        ::= MulExp | AddExp ("+" | "-") MulExp;
//! RelExp        ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
//! EqExp         ::= RelExp | EqExp ("==" | "!=") RelExp;
//! LAndExp       ::= EqExp | LAndExp "&&" EqExp;
//! LOrExp        ::= LAndExp | LOrExp "||" LAndExp;
//! ConstExp      ::= Exp;

Comma<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

CommaNotEmpty<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T> => {
      v.push(e);
      v
    }
};

pub _CompUnit: AstNode = {
  <_CompUnitItem+> => AstNode::new_comp_unit(<>)
};

_CompUnitItem: AstNode = {
  <_FuncDef>  => AstNode::new_comp_unit_item_func_def(<>)
  <_Decl>     => AstNode::new_comp_unit_item_decl(<>)
};

_Decl: AstNode = {
  <_ConstDecl>  => AstNode::new_decl_const_decl(<>)
  <_VarDecl>    => AstNode::new_decl_var_decl(<>)
};

_ConstDecl: AstNode = {
  "const" <_BType> <CommaNotEmpty<_ConstDef>> ";" 
    => AstNode::new_const_decl(<>)
};

_ConstIdxList: AstNode = {
  <("[" <_ConstExp> "]")*> 
    => AstNode::new_const_idx_list(<>)
};

_BType: AstNode = {
  "int" => AstNode::new_btype()
}

_ConstDef: AstNode = {
  <ident: _Ident> <idx: _ConstIdxList> "=" <const_init_val: _ConstInitVal> => {
    AstNode::new_const_def(<>)
  }
};

_ConstInitVal: AstNode = {
  <_ConstExp>                     => AstNode::new_const_init_val_single(<>)
  "{" <Comma<_ConstInitVal>> "}"  => AstNode::new_const_init_val_sequence(<>)
};

_VarDecl: AstNode = {
  <_BType> <var_defs: CommaNotEmpty<_VarDef>> ";" 
    => AstNode::new_var_decl(var_defs)
};

_VarDef: AstNode = {
  <_Ident> <_ConstIdxList> <("=" <_InitVal>)?> 
    => AstNode::new_var_def(<>)
};

_InitVal: AstNode = {
  <_Exp>                    => AstNode::new_init_val_single(<>),
  "{" <Comma<_InitVal>> "}" => AstNode::new_init_val_sequence(<>)
};


_FuncDef: AstNode = {
  "void" <ident: _Ident> "(" <func_f_params: _FuncFParams> ")" <block: _Block> 
    => AstNode::new_func_def(false, ident, func_f_params, block),
  <_BType> <ident: _Ident> "(" <func_f_params: _FuncFParams> ")" <block: _Block>
    => AstNode::new_func_def(true, ident, func_f_params, block)
};

_FuncFParams: AstNode = {
  <Comma<_FuncFParam>> => AstNode::new_func_f_params(<>)
};

_FuncFParam: AstNode = {
  <_BType> <_Ident> <("[" "]" <_ConstIdxList>)?> 
    => AstNode::new_func_f_param(<>)
};

_Block: AstNode = {
  "{" <_BlockItem*> "}" => AstNode::new_block(<>)
};

_BlockItem: AstNode = {
  <_Decl> => AstNode::new_block_item_decl(<>)
  <_Stmt> => AstNode::new_block_item_stmt(<>)
};

_Stmt: AstNode = {
  <_StmtIfClose>      => <>,
  <_StmtIfOpen>       => <>
};

_StmtIfOpen: AstNode = {
  "if" "(" <exp: _Exp> ")" <stmt: _Stmt> 
            => AstNode::new_stmt_if_else(exp, stmt, None),
  "if" "(" <exp: _Exp> ")" <stmt1: _StmtIfClose> "else" <stmt2: _StmtIfOpen> 
            => AstNode::new_stmt_if_else(exp, stmt1, Some(stmt2)),
  "while" "(" <exp: _Exp> ")" <stmt: _StmtIfOpen> 
            => AstNode::new_stmt_while(exp, stmt)
};

_StmtIfClose: AstNode = {
  <_StmtNotEndInStmt>   => <>, 
  "if" "(" <exp: _Exp> ")" <stmt1: _StmtIfClose> "else" <stmt2: _StmtIfClose> 
          => AstNode::new_stmt_if_else(exp, stmt1, Some(stmt2)),
  "while" "(" <exp: _Exp> ")" <stmt: _StmtIfClose>
          => Ast::new_stmt_while(exp, stmt)
};

_StmtNotEndInStmt: AstNode = {
  <_LVal> "=" <_Exp> ";"      => AstNode::new_stmt_assign(<>),
  <_Exp?> ";"                 => AstNode::new_stmt_exp(<>),
  <_Block>                    => AstNode::new_stmt_block(<>),
  "break" ";"                 => AstNode::new_stmt_break(),
  "continue" ";"              => AstNode::new_stmt_continue(),
  "return" <_Exp?> ";"        => AstNode::new_stmt_return(<>)
};

_Exp: AstNode = 
  <_LOrExp> => <>;

_LVal: AstNode = {
  <name: _Ident> <idx: ("[" <_Exp> "]")*> => AstNode::new_lval(<>)
};

_PrimaryExp: AstNode = {
  "(" <_Exp> ")"  => <>,
  <_LVal>         => <>,
  <_Number>       => AstNode::new_number(<>)
};

_Number: AstNode = {
  <_IntConst> => <>
};

_UnaryExp: AstNode = {
  <_PrimaryExp>                   => <>,
  <_Ident> "(" <_FuncRParams> ")" => AstNode::new_exp_call(<>),
  <_UnaryOp> <_UnaryExp> 
                                  => AstNode::new_exp_unary(<>)
};

_UnaryOp: UnaryOp = {
  "+" => UnaryOp::Pos,
  "-" => UnaryOp::Neg,
  "!" => UnaryOp::Not
};

_FuncRParams: AstNode = {
  CommaNotEmpty<_Exp> => AstNode::new_func_r_params(<>)
};

_MulOp: BinaryOp = {
  "*" => BinaryOp::Mul,
  "/" => BinaryOp::Div,
  "%" => BinaryOp::Mod
};

_AddOp: BinaryOp = {
  "+" => BinaryOp::Add,
  "-" => BinaryOp::Sub
};

_RelOp: BinaryOp = {
  "<"  => BinaryOp::Lt,
  ">"  => BinaryOp::Gt,
  "<=" => BinaryOp::Le,
  ">=" => BinaryOp::Ge
};

_EqOp: BinaryOp = {
  "==" => BinaryOp::Eq,
  "!=" => BinaryOp::Ne
};

_MulExp: AstNode = {
  <_MulExp> <_MulOp> <_UnaryExp> 
                => AstNode::new_exp_binary(<>),
  <_UnaryExp>   => <>
};

_AddExp: AstNode = {
  <_AddExp> <_AddOp> <_MulExp> 
                => AstNode::new_exp_binary(<>),
  <_MulExp>     => <>
};

_RelExp: AstNode = {
  <_RelExp> <_RelOp> <_AddExp> 
                => AstNode::new_exp_binary(<>),
  <_AddExp>     => <>
};

_EqExp: AstNode = {
  <_EqExp> <_EqOp> <_RelExp> 
                => AstNode::new_exp_binary(<>),
  <_RelExp>     => <>
};

_LAndExp: AstNode = {
  <land_exp: _LAndExp> "&&" <eq_exp: _EqExp> 
                => AstNode::new_exp_binary(land_exp, BinaryOp::And, eq_exp),
  <_EqExp>      => <>
};

_LOrExp: AstNode = {
  <lor_exp: _LOrExp> "||" <land_exp: _LAndExp> 
                => AstNode::new_exp_binary(lor_exp, BinaryOp::Or, land_exp),
  <_LAndExp>    => <>
};

_Ident: String = 
  r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

_IntConst: i32 = {
  r"[1-9][0-9]*"        => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*"            => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+"  => i32::from_str_radix(&<>[2..], 16).unwrap()
};

_ConstExp: AstNode = 
  <_Exp> => <>;
