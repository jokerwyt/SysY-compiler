use crate::ast::{basic::*, expr::*, prog::*};

grammar;

match {
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/" => {},
  _
}

//! The EBNF we followed:
//! 
//! CompUnit      ::= [CompUnit] (Decl | FuncDef);
//! Decl          ::= ConstDecl | VarDecl;
//! ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
//! BType         ::= "int";
//! ConstIdxList  ::= {"[" ConstExp "]"};
//! ConstDef      ::= IDENT ConstIdxList "=" ConstInitVal;
//! ConstInitVal  ::= ConstExp | "{" [ConstInitVal {"," ConstInitVal}] "}";
//! VarDecl       ::= BType VarDef {"," VarDef} ";";
//! VarDef        ::= IDENT ConstIdxList
//!         | IDENT ConstIdxList "=" InitVal;
//! InitVal       ::= Exp | "{" [InitVal {"," InitVal}] "}";
//!
//! FuncDef       ::= FuncType IDENT "(" [FuncFParams] ")" Block;
//! FuncType      ::= "void" | "int";
//! FuncFParams   ::= FuncFParam {"," FuncFParam};
//! FuncFParam    ::= BType IDENT ["[" "]" ConstIdxList];
//!
//! Block         ::= "{" {BlockItem} "}";
//! BlockItem     ::= Decl | Stmt;
//!
//! We have to pay some effort to solve if-if-else conflict:
//! 
//! Stmt          ::= StmtExceptIf
//!         | StmtIfElse
//!         | "if" "(" Exp ")" Stmt ";"
//! StmtIfElse    ::= 
//!           "if" "(" Exp ")" StmtExceptIf "else" Stmt ";";
//!         | "if" "(" Exp ")" StmtIfElse "else" Stmt ";";
//! StmtExceptIf  ::= LVal "=" Exp ";"
//!         | [Exp] ";"
//!         | Block
//!         | "while" "(" Exp ")" Stmt
//!         | "break" ";"
//!         | "continue" ";"
//!         | "return" [Exp] ";";
//!
//! Exp           ::= LOrExp;
//! LVal          ::= IDENT {"[" Exp "]"};
//! PrimaryExp    ::= "(" Exp ")" | LVal | Number;
//! Number        ::= INT_CONST;
//! UnaryExp      ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
//! UnaryOp       ::= "+" | "-" | "!";
//! FuncRParams   ::= Exp {"," Exp};
//! MulExp        ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
//! AddExp        ::= MulExp | AddExp ("+" | "-") MulExp;
//! RelExp        ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
//! EqExp         ::= RelExp | EqExp ("==" | "!=") RelExp;
//! LAndExp       ::= EqExp | LAndExp "&&" EqExp;
//! LOrExp        ::= LAndExp | LOrExp "||" LAndExp;
//! ConstExp      ::= Exp;

Comma<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

CommaNotEmpty<T>: Vec<T> = { 
    <mut v:(<T> ",")*> <e:T> => {
      v.push(e);
      v
    }
};

pub _CompUnit: CompUnit = {
  <_CompUnitItem+> => <>
};

_CompUnitItem: CompUnitItem = {
  <_FuncDef>  => CompUnitItem::FuncDef(<>),
  <_Decl>     => CompUnitItem::Decl(<>),
};

_Decl: Decl = {
  <_ConstDecl>  => Decl::Const(<>),
  <_VarDecl>    => Decl::Var(<>),
};

_ConstDecl: ConstDecl = {
  "const" <btype: _BType> <const_defs: CommaNotEmpty<_ConstDef>> ";" 
    => ConstDecl { <> }
};

_ConstIdxList: Vec<Exp> = {
  <("[" <_ConstExp> "]")*> 
    => <>
};

_BType: BType = 
  "int" => BType::Int;

_ConstDef: ConstDef = {
  <ident: _Ident> <idx: _ConstIdxList> "=" <const_init_val: _ConstInitVal> => {
    ConstDef { <> }
  }
};

_ConstInitVal: ConstInitVal = {
  <_ConstExp>                     => ConstInitVal::Single(<>),
  "{" <Comma<_ConstInitVal>> "}"  => ConstInitVal::Sequence(<>),
};

_VarDecl: VarDecl = {
  <btype: _BType> <var_defs: CommaNotEmpty<_VarDef>> ";" 
    => VarDecl { <> }
};

_VarDef: VarDef = {
  <ident: _Ident> <idx: _ConstIdxList> <init_val: ("=" <_InitVal>)?> 
    => VarDef { <> }
};

_InitVal: InitVal = {
  <_Exp>                    => InitVal::Single(<>),
  "{" <Comma<_InitVal>> "}" => InitVal::Sequence(<>),
};


_FuncDef: FuncDef = {
  <func_type: _BType> <ident: _Ident> "(" <func_f_params: _FuncFParams> ")" <block: _Block> 
    => FuncDef { <> }
};

_FuncFParams: Vec<FuncFParam> = {
  <Comma<_FuncFParam>> => <>
};

_FuncFParam: FuncFParam = {
  <btype: _BType> <ident: _Ident> <shape_except_first_dimension: ("[" "]" <_ConstIdxList>)?> 
    => FuncFParam { <> }
};

_Block: Block = {
  "{" <_BlockItem*> "}" => <>
};

_BlockItem: BlockItem = {
  <_Decl> => BlockItem::Decl(<>),
  <_Stmt> => BlockItem::Stmt(<>),
};

_Stmt: Stmt = {
  <_StmtExceptIf>   => <>,
  <_StmtIfElse>     => <>,
  "if" "(" <exp: _Exp> ")" <stmt: _Stmt>  ";" 
                    => Stmt::IfElse(exp, Box::new(stmt), None)
};

_StmtIfElse: Stmt = {
  "if" "(" <exp: _Exp> ")" <stmt1: _StmtExceptIf> "else" <stmt2: _Stmt> ";"
      => Stmt::IfElse(exp, Box::new(stmt1), Some(Box::new(stmt2))),
  "if" "(" <exp: _Exp> ")" <stmt1: _StmtIfElse> "else" <stmt2: _Stmt> ";"
      => Stmt::IfElse(exp, Box::new(stmt1), Some(Box::new(stmt2))),
};

_StmtExceptIf: Stmt = {
  <_LVal> "=" <_Exp> ";"      => Stmt::Assign(<>),
  <_Exp?> ";"                 => Stmt::Exp(<>),
  <_Block>                    => Stmt::Block(<>),
  "while" "(" <exp: _Exp> ")" <stmt: _Stmt> 
                              => Stmt::While(exp, Box::new(stmt)),
  "break" ";"                 => Stmt::Break,
  "continue" ";"              => Stmt::Continue,
  "return" <_Exp?> ";"        => Stmt::Return(<>),
};

_Exp: Exp = 
  <_LOrExp> => <>;

_LVal: LVal = {
  <name: _Ident> <idx: ("[" <_Exp> "]")*> => LVal { <> }
};

_PrimaryExp: Exp = {
  "(" <_Exp> ")"  => <>,
  <_LVal>         => Exp::LVal(<>),
  <_Number>       => Exp::Number(<>),
};

_Number: Number = {
  <_IntConst> => <>
};

_UnaryExp: Exp = {
  <_PrimaryExp>                   => <>,
  <_Ident> "(" <_FuncRParams> ")" => Exp::Call(<>),
  <unary_op: _UnaryOp> <unary_exp: _UnaryExp> 
                                  => Exp::Unary(unary_op, Box::new(unary_exp)),
};

_UnaryOp: UnaryOp = {
  "+" => UnaryOp::Pos,
  "-" => UnaryOp::Neg,
  "!" => UnaryOp::Not,
};

_FuncRParams: Vec<Exp> = {
  CommaNotEmpty<_Exp> => <>
};

_MulExp: Exp = {
  <mul_exp: _MulExp> <op: r"[*/%]"> <unary_exp: _UnaryExp> 
                => Exp::Binary(Box::new(mul_exp), BinaryOp::from_str(op).unwrap(), Box::new(unary_exp)),
  <_UnaryExp>   => <>,
};

_AddExp: Exp = {
  <add_exp: _AddExp> <op: r"[+-]"> <mul_exp: _MulExp> 
                => Exp::Binary(Box::new(add_exp), BinaryOp::from_str(op).unwrap(), Box::new(mul_exp)),
  <_MulExp>     => <>,
};

_RelExp: Exp = {
  <rel_exp: _RelExp> <op: r"(<=|>=|<|>)"> <add_exp: _AddExp> 
                => Exp::Binary(Box::new(rel_exp), BinaryOp::from_str(op).unwrap(), Box::new(add_exp)),
  <_AddExp>     => <>,
};

_EqExp: Exp = {
  <eq_exp: _EqExp> <op: r"(==|!=)"> <rel_exp: _RelExp> 
                => Exp::Binary(Box::new(eq_exp), BinaryOp::from_str(op).unwrap(), Box::new(rel_exp)),
  <_RelExp>     => <>,
};

_LAndExp: Exp = {
  <land_exp: _LAndExp> "&&" <eq_exp: _EqExp> 
                => Exp::Binary(Box::new(land_exp), BinaryOp::And, Box::new(eq_exp)),
  <_EqExp>      => <>,
};

_LOrExp: Exp = {
  <lor_exp: _LOrExp> "||" <land_exp: _LAndExp> 
                => Exp::Binary(Box::new(lor_exp), BinaryOp::Or, Box::new(land_exp)),
  <_LAndExp>    => <>,
};

_Ident: String = 
  r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

_IntConst: i32 = {
  r"[1-9][0-9]*"        => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*"            => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+"  => i32::from_str_radix(&<>[2..], 16).unwrap(),
};

_ConstExp: Exp = 
  <_Exp> => <>;